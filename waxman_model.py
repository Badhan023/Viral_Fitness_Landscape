import hypercube_graph as hg
import networkx as nx
import pandas as pd
import math
import sys
import random
import logging
from itertools import combinations
import logging
import plotly.graph_objects as go
import matplotlib.pyplot as plt

print ("binary string size:")
print (sys.argv[1])                         #binary string size

print ("Number of nodes in the Waxman model:")
print (sys.argv[2])                         #initial number of nodes

print ("Mutation rate:")
print (sys.argv[3])

print ("Duration:")
print (sys.argv[4])

print ("Infection probability:")
print (sys.argv[5])

mutation_rate = float(sys.argv[3])
total_itererations = 5000
standard_timer = int(sys.argv[4])
infection_probability = float(sys.argv[5])

#all possible states generation
arr = [None]*int(sys.argv[1])
all_possible_states = []

def waxman_graph(
    n, states, beta=0.3, alpha=0.2, L=None, domain=(0, 0, 1, 1), metric=None):
    """Returns a Waxman random graph.

    The Waxman random graph model places `n` nodes uniformly at random
    in a rectangular domain. Each pair of nodes at distance `d` is
    joined by an edge with probability

    .. math::
            p = \beta \exp(-d / \alpha L).

    This function implements both Waxman models, using the `L` keyword
    argument.

    * Waxman-1: if `L` is not specified, it is set to be the maximum distance
      between any pair of nodes.
    * Waxman-2: if `L` is specified, the distance between a pair of nodes is
      chosen uniformly at random from the interval `[0, L]`.

    Parameters
    ----------
    n : int or iterable
        Number of nodes or iterable of nodes
    beta: float
        Model parameter
    alpha: float
        Model parameter
    L : float, optional
        Maximum distance between nodes.  If not specified, the actual distance
        is calculated.
    domain : four-tuple of numbers, optional
        Domain size, given as a tuple of the form `(x_min, y_min, x_max,
        y_max)`.
    metric : function
        A metric on vectors of numbers (represented as lists or
        tuples). This must be a function that accepts two lists (or
        tuples) as input and yields a number as output. The function
        must also satisfy the four requirements of a `metric`_.
        Specifically, if $d$ is the function and $x$, $y$,
        and $z$ are vectors in the graph, then $d$ must satisfy

        1. $d(x, y) \ge 0$,
        2. $d(x, y) = 0$ if and only if $x = y$,
        3. $d(x, y) = d(y, x)$,
        4. $d(x, z) \le d(x, y) + d(y, z)$.

        If this argument is not specified, the Euclidean distance metric is
        used.

        .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29

    seed : integer, random_state, or None (default)
        Indicator of random number generation state.
        See :ref:`Randomness<randomness>`.

    Returns
    -------
    Graph
        A random Waxman graph, undirected and without self-loops. Each
        node has a node attribute ``'pos'`` that stores the position of
        that node in Euclidean space as generated by this function.

    Examples
    --------
    Specify an alternate distance metric using the ``metric`` keyword
    argument. For example, to use the "`taxicab metric`_" instead of the
    default `Euclidean metric`_::

        >>> dist = lambda x, y: sum(abs(a - b) for a, b in zip(x, y))
        >>> G = nx.waxman_graph(10, 0.5, 0.1, metric=dist)

    .. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry
    .. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance

    Notes
    -----
    Starting in NetworkX 2.0 the parameters alpha and beta align with their
    usual roles in the probability distribution. In earlier versions their
    positions in the expression were reversed. Their position in the calling
    sequence reversed as well to minimize backward incompatibility.

    References
    ----------
    .. [1]  B. M. Waxman, *Routing of multipoint connections*.
       IEEE J. Select. Areas Commun. 6(9),(1988) 1617--1622.
    """
    

    G = nx.empty_graph(n)
    #G = nx.graph()
    #G.add_nodes_from(range(n))
    (xmin, ymin, xmax, ymax) = domain
    # Each node gets a uniformly random position in the given rectangle.
    pos = {v: (random.uniform(xmin, xmax), random.uniform(ymin, ymax)) for v in G}
    nx.set_node_attributes(G, pos, "pos")
    # If no distance metric is provided, use Euclidean distance.
    if metric is None:
        metric = math.dist
    # If the maximum distance L is not specified (that is, we are in the
    # Waxman-1 model), then find the maximum distance between any pair
    # of nodes.
    #
    # In the Waxman-1 model, join nodes randomly based on distance. In
    # the Waxman-2 model, join randomly based on random l.
    if L is None:
        L = max(metric(x, y) for x, y in combinations(pos.values(), 2))

        def dist(u, v):
            return metric(pos[u], pos[v])

    else:

        def dist(u, v):
            return random.random() * L

    # `pair` is the pair of nodes to decide whether to join.
    def should_join(pair):
        return random.random() < beta * math.exp(-dist(*pair) / (alpha * L))
    
    #assiging weight to each weight in the range of [0,1]
    
    G.add_edges_from(filter(should_join, combinations(G, 2)))
    for i in G.edges():
        G[i[0]][i[1]]["weight"]=random.uniform(0, 1)

    #assigining status to each node that includes 'inactive', strain #
    
             
    status = {v: random.choice(states) for v in G}
    nx.set_node_attributes(G, status, "status")
    
    #need to keep max nodes inactive in the first place
    for node in G:
        if G.nodes[node]["status"] != "":
            rand = random.uniform(0,1)
            if rand <= 0.8:                #keeping high probability to convert one active node to inactive
                G.nodes[node]["status"] = ""
    
    
    
    #assigning timer to each active node, [1,2,3], timer increases in each loop and when a node's timer reaches 3, we reset it to 0 and make the status inactive
    timer = {v: random.choice([1,2,3]) for v in G}
    nx.set_node_attributes(G, timer, "timer")
    
    #assign inactive nodes' timers to 0
    for node in G:
        if G.nodes[node]["status"] == "":           #inactive nodes
            G.nodes[node]["timer"] = 0
    
    return G

def generate_initial_states(H):     
    #keeping 2 states including inactive state
    states=[""]           #"" is the inactive state
    least_fit_state = H.get_least_fit_state()
    states.append(least_fit_state)                   #taking the first two states
    #states.append(random.choice(all_possible_states))
    
    
    print (states)
    return states

def sort_immunity(G):
    immunity_queue = {}                 #dictionary with nodes and immunity
    for i in G.nodes():
        immunity_queue[i]=G.nodes[i]["immunity"]
    
    sorted_queue = dict(sorted(immunity_queue.items(), key=lambda item: item[1]))   #sort the dictionary according to the immunity value
    return sorted_queue

def count_active_neighbors(G, u):           #active neighbors of node u in graph G
    #G is the graph
    #we are looking for the active neighbors of node u
    count=0
    for n in G.neighbors(u):
        if G.nodes[n]["status"]!="":
            count = count+1
    return count    

def get_active_states(G):               #returns all the states existing in the model
    state_list = []
    #we want get the union of all the states existing in the model
    for node in G:
        if G.nodes[node]["status"] != "":           #not inactive
            state_list.append(G.nodes[node]["status"])
    final_list = list(set(state_list))
    
    return final_list

def same_state_hosts(G, state):
    list_of_hosts = []
    for node in G:
        if G.nodes[node]["status"] == state:
            list_of_hosts.append(node)
    return list_of_hosts

def update_timer_and_status(G, limit):
    for node in G:
        if G.nodes[node]["status"] != "":               #not inactive
            if G.nodes[node]["timer"] < limit:
                G.nodes[node]["timer"] = G.nodes[node]["timer"]+1
            elif G.nodes[node]["timer"] == limit:
                G.nodes[node]["timer"] = 0              #reset timer
                G.nodes[node]["status"] = ""            #make it inactive
    
        
def Simulated_Annealing(H, state, T=1, Tmin=0.00001, alpha=0.9):
    neighbors_dict = H.get_neighbors(state)
    neighbors_list = []
    for i in neighbors_dict:
        neighbors_list.append(i)
    current_state = state
    
    #number_of_iterations = int(sys.argv[1])        #not necessary
    
    while T>=Tmin:
        #for i in range(math.floor(number_of_iterations/2)):            #not necessary
        new_state = random.choice(neighbors_list)
        del_E = H.get_fitness(new_state) - H.get_fitness(current_state)
        if del_E > 0:                       #since we are maximizing
            current_state = new_state
            
        elif random.random() > math.exp((del_E/T)):           #since maximizing
            current_state = new_state
            
        T = T*alpha
    return current_state
    
    

def Mutation(G, H, mutation_rate):
    temp=pow(2,int(sys.argv[1]))
    for node in G:
        if G.nodes[node]["status"] != "":
            next_fit_state = Simulated_Annealing(H, G.nodes[node]["status"], T=temp)
            rand_mutation = random.uniform(0,1)
            if rand_mutation < mutation_rate:
                G.nodes[node]["status"] = next_fit_state
        
            
def Infection_Decision(G, H, gamma=0.5):        #gamma is the probability of a node to be infected
    infected_list = {}          #list to keep track of infections, key->node, value->infecting strain
    for node in G:
        if G.nodes[node]["status"] == "":           #inactive node
            node_random = random.uniform(0,1)
            if node_random <= gamma:
                selected_neighbors = []
                for n in G.neighbors(node):
                    if G.nodes[n]["status"] != "":          #not inactive
                        selected_neighbors.append(G.nodes[n]["status"])
                strain_count = {}
                for i in selected_neighbors:
                    if i in strain_count:
                        strain_count[i] = strain_count[i]+1
                    else:
                        strain_count[i] = 1
                #total_infection = 0
                #for i in strain_count:
                #    total_infection = total_infection+strain_count[i]           
                
                #set weight to each existing strains
                #(strain_count[i]/len(selected_neighbors))*
                strain_weight = {}
                if len(selected_neighbors)>0:           #in case there are no neighbors that are selected
                    for i in strain_count:
                        #strain_weight[i] = ((strain_count[i]/len(selected_neighbors))*0.5) + (H.get_fitness(i)*0.5)
                        strain_weight[i] =(strain_count[i]/len(selected_neighbors))*H.get_fitness(i)
                
                #find the fittest strain according to strain weight
                fittest_strain = ""
                max_weight = -1
                for i in strain_weight:
                    if strain_weight[i] > max_weight:
                        max_weight = strain_weight[i]
                        fittest_strain = i
                    elif strain_weight[i] == max_weight:
                        if (H.get_fitness(i)>H.get_fitness(fittest_strain)):
                            fittest_strain = i
                        elif (H.get_fitness(i) == H.get_fitness(fittest_strain)):
                            rand = random.choice([0,1])
                            if rand == 1:           #change to new strain
                                fittest_strain = i
                
                #keeping track of which node infected by which strain
                if max_weight != -1:                        #there is a change
                    infected_list[node] = fittest_strain
    return infected_list   

def Infection_and_Disinfection(G, H, infection_list):
    #G is the network model, H the hypercube and infection_list is the dictionary returned from Infection_Decision
    
    #disinfection and timer updating
    update_timer_and_status(G, standard_timer)    
    
    #infection updating
    for node in infection_list:
        G.nodes[node]["status"] = infection_list[node]
        G.nodes[node]["timer"] = 1          #starting the timer for the node
        
    

def Infection_Propagation(G, H):
    i=0
    iteration_vs_strain={}          #dictionary for count of strains per iteration
    iteration=[]
    strain_count=[]
    total_strain_list=H.get_strains()
    
    strain_dict={}                              #keep track of the active and inactive strains
    for strain in total_strain_list:
        strain_dict[strain]=[]
    flag = False
    walk_length=-1
    total_infected_hosts=[]
    while (1):
        #before mutation
        active_states = get_active_states(G)
        active_states.sort()
        iteration.append(i)
        strain_count.append(len(active_states))
        
        #PHASE 1: MUTATION
        Mutation(G, H, mutation_rate)
        logger.info("Iteration : "+str(i))
        logger.info("After mutation: ")
        active_states = get_active_states(G)
        active_states.sort()
        
        
        #fittest state exists?
        exist = active_states.count(H.get_fittest_state())
        
        
        #PHASE 2: INFECTION DECISION
        infection_list = Infection_Decision(G, H, infection_probability)
        logger.info("new infected hosts and respective strains : " + str(infection_list))
    
        #PHASE 3: INFECTION AND DISINFECTION
        Infection_and_Disinfection(G, H, infection_list)
        
        logger.info("Active states : "+ str(active_states))
        
        infected_hosts=0
        
        for state in active_states:
            logger.info(state + " : " + str(same_state_hosts(G, state)))
            infected_hosts = infected_hosts + len(same_state_hosts(G, state))
        
        total_infected_hosts.append(infected_hosts)
            
        for state in total_strain_list:
            if state in active_states:
                strain_dict[state].append(len(same_state_hosts(G, state)))
            else:
                strain_dict[state].append(0)
        logger.info("Inactive state : " + str(same_state_hosts(G, "")))
        
        if active_states == [] or i==total_itererations:     #empty list
            print ("done")
            print (i)
            if active_states == []:
                print ("active states empty")
            else:
                print ("all iterations are complete")
            break
        if exist > 0 and flag == False:               #that mean reached the fittest state
            print ("ase")
            print (i)
            walk_length=i
            flag = True
            break
            
        i = i+1
        
    iteration_vs_strain["iteration"]=iteration
    iteration_vs_strain["count of strain"]=strain_count
    
    df1 = pd.DataFrame(iteration_vs_strain)
    df2 = pd.DataFrame(strain_dict)
    final_df = pd.concat([df1, df2], axis=1, join="inner")
    print (final_df)
    df1.to_csv("table.csv")
    final_df.to_csv("final_table.csv")
    
    return walk_length
    
    
def print_graph(G):
    
    logger.info("Waxman model nodes : "+ str(G.nodes()))
    logger.info("Waxman model nodes : "+ str(G.edges()))
    #printing node information
    logger.info("Node information : ")
    for node in G:
        logger.info("node id: "+str(node) + " node status: " + str(G.nodes[node]["status"]) + " node timer: " + str(G.nodes[node]["timer"]))
        
def draw_graph(G, H):
    
    strain_value={}
    j=1
    for strain in H.get_strains():
        strain_value[strain]=j
        j=j+1

    
    #color nodes
    node_text=[]
    node_value = []
    for node in G:
        if G.nodes[node]["status"]=="":
            node_value.append(0)
            node_text.append("inactive")
        else:
            node_value.append(strain_value[G.nodes[node]["status"]])
            node_text.append(G.nodes[node]["status"])
    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = G.nodes[edge[0]]['pos']
        x1, y1 = G.nodes[edge[1]]['pos']
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)
    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines')
    node_x = []
    node_y = []
    for node in G.nodes():
        x, y = G.nodes[node]['pos']
        node_x.append(x)
        node_y.append(y)
    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        marker=dict(
            showscale=True,
            # colorscale options
            #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
            #colorscale='Rainbow',
            reversescale=True,
            color=[],
            size=15,
            colorbar=dict(
                thickness=10,
                title='Node Strain',
                xanchor='left',
                titleside='right'
            ),
            line_width=2))
    
    
    
    node_trace.marker.color = node_value
    node_trace.text = node_text
        
    fig = go.Figure(data=[edge_trace, node_trace],
             layout=go.Layout(
                title='<br>Waxman Model',
                titlefont_size=16,
                showlegend=False,
                hovermode='closest',
                margin=dict(b=20,l=5,r=5,t=40),
                annotations=[ dict(
                    #text="Python code: <a href='https://plotly.com/ipython-notebooks/network-graphs/'> https://plotly.com/ipython-notebooks/network-graphs/</a>",
                    showarrow=True,
                    xref="paper", yref="paper",
                    x=0.005, y=-0.002 ) ],
                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                )
    #fig.show()
    fig.write_image("model.png")
    

def create_hypercube():
    hc = hg.hypercube(2, int(sys.argv[1]))
    hc.get_all_vertices()
    hc.build_hypercube()
    return hc
    

# Create and configure logger
name = sys.argv[3]+".log"
print (name)
logging.basicConfig(filename="badhan.log",
                    format='%(asctime)s %(message)s',
                    filemode='w')
    
# Creating an object
logger = logging.getLogger()
    
# Setting the threshold of logger to DEBUG
logger.setLevel(logging.DEBUG)
    
logger.info("bits : "+str(sys.argv[1]))
logger.info("count of hosts : "+str(sys.argv[2]))


#creating hypercube
hypercube = create_hypercube()
logger.info("hypercube information : ")
hypercube.print_hypercube()

print (hypercube.get_fittest_state())


states = generate_initial_states(hypercube)

#creating Waxman model
G_wax = waxman_graph(int(sys.argv[2]), states, domain=[0,0,10,10])

logger.info("Creating Waxman Model.....")
logger.info("nodes : "+sys.argv[2])
logger.info("Active strains : "+ str(get_active_states(G_wax)))

logger.info ("bits : "+str(sys.argv[1]))

#printing the graph
print_graph(G_wax)
#draw_graph(G_wax)
logger.info("Initial network :")
active_states = get_active_states(G_wax)
active_states.sort()
logger.info("Active states : "+ str(active_states))
draw_graph(G_wax, hypercube)
        
for state in active_states:
    logger.info(state + " : " + str(same_state_hosts(G_wax, state)))

logger.info("Inactive state : " + str(same_state_hosts(G_wax, "")))

walk_length = Infection_Propagation(G_wax, hypercube)

print (walk_length)


total_walklength=0
for i in range(100):
    G_wax = waxman_graph(int(sys.argv[2]), states, domain=[0,0,10,10])
    walk_length = Infection_Propagation(G_wax, hypercube)
    if walk_length == -1:
        print ("out of boundary")
        break
    total_walklength=total_walklength+walk_length
avg_walk = total_walklength/100
print("average walk : " + str(avg_walk))
